#![allow(non_snake_case)]

use etebase::{
    User,
    Client,
    Account,

    Collection,
    CollectionMetadata,
    Item,
    ItemMetadata,

    UserProfile,

    error::Result,
    managers::{
        CollectionManager,
        ItemManager,
    },
};

use crate::{
    Response,
    HttpClient,
    client_new_with_impl,

    FetchOptions,
};

#[cfg(feature = "java")]
use crate::jni_c_header::*;

#[cfg(feature = "android")]
use jni_sys::*;

fn response_reset_ok(resp: &mut Response, bytes: &[u8], status: u16) {
    resp.reset_ok(bytes.to_vec(), status);
}

foreign_class!(class Response {
    self_type Response;
    private constructor = empty;
    fn response_reset_ok(&mut self, bytes: &[u8], status: u16); alias reset_ok;
    fn Response::reset_err(&mut self, err: String);
});

foreign_callback!(callback HttpClient {
    self_type HttpClient;
    get = HttpClient::get(&self, url: &str, auth_token: &str, response: Response);
    post = HttpClient::post(&self, url: &str, auth_token: &str, body: Vec<u8>, response: Response);
    put = HttpClient::put(&self, url: &str, auth_token: &str, body: Vec<u8>, response: Response);
    patch = HttpClient::patch(&self, url: &str, auth_token: &str, body: Vec<u8>, response: Response);
    del = HttpClient::delete(&self, url: &str, auth_token: &str, response: Response);
});

foreign_class!(class Client {
    self_type Client;
    private constructor = empty;
    fn client_new_with_impl(server_url: &str, imp: Box<HttpClient>) -> Result<Client>;
    fn Client::set_api_base(&mut self, server_url: &str) -> Result<()>; alias setApiBase;
    foreign_code r#"
    public static Client create(okhttp3.OkHttpClient client, String server_url) {
        return com.etebase.client.http_bridge.HttpClientBridge.create(client, server_url);
    }

    static {
        System.loadLibrary("etebase_android");
    }
"#;
});

foreign_class!(class User {
    self_type User;
    constructor User::new(username: &str, email: &str) -> User;
    fn setUsername(&mut self, username: &str) {
        this.set_username(username);
    }
    fn User::username(&self) -> &str; alias getUsername;
    fn setEmail(&mut self, email: &str) {
        this.set_email(email);
    }
    fn User::email(&self) -> &str; alias getEmail;
});

foreign_class!(class Account {
    self_type Account;
    private constructor = empty;
    fn Account::login(client: Client, username: &str, password: &str) -> Result<Account>;
    fn Account::signup(client: Client, user: &User, password: &str) -> Result<Account>;
    fn Account::fetch_token(&mut self) -> Result<()>; alias fetchToken;
    fn Account::force_api_base(&mut self, api_base: &str) -> Result<()>; alias forceApiBase;
    fn Account::change_password(&mut self, password: &str) -> Result<()>; alias changePassword;
    fn Account::logout(&mut self) -> Result<()>;
    fn Account::collection_manager(&self) -> Result<CollectionManager>; alias getCollectionManager;
});

type CollectionListResponse = etebase::CollectionListResponse<Collection>;

foreign_class!(class CollectionListResponse {
    self_type CollectionListResponse;
    private constructor = empty;
    fn CollectionListResponse::stoken(&self) -> Option<&str>; alias getStoken;
    fn CollectionListResponse::data(&self) -> &Vec<Collection>; alias getData;
    fn CollectionListResponse::done(&self) -> bool; alias getDone;
});

type ItemListResponse = etebase::ItemListResponse<Item>;

foreign_class!(class ItemListResponse {
    self_type ItemListResponse;
    private constructor = empty;
    fn ItemListResponse::stoken(&self) -> Option<&str>; alias getStoken;
    fn ItemListResponse::data(&self) -> &Vec<Item>; alias getData;
    fn ItemListResponse::done(&self) -> bool; alias getDone;
});

foreign_class!(class FetchOptions {
    self_type FetchOptions;
    constructor FetchOptions::new() -> FetchOptions;
    fn FetchOptions::limit(&mut self, limit: usize);
    fn FetchOptions::prefetch(&mut self, prefetch: bool);
    fn FetchOptions::with_collection(&mut self, with_collection: bool);
    fn FetchOptions::iterator(&mut self, iterator: Option<&str>);
    fn FetchOptions::stoken(&mut self, stoken: Option<&str>);
});

mod CollectionMetadataFixes {
    #![allow(non_snake_case)]
    use super::*;

    pub fn setCollectionType(md: &mut CollectionMetadata, type_: &str) {
        md.set_collection_type(type_);
    }

    pub fn setName(md: &mut CollectionMetadata, name: &str) {
        md.set_name(name);
    }

    pub fn setDescription(md: &mut CollectionMetadata, description: Option<&str>) {
        md.set_description(description);
    }

    pub fn setColor(md: &mut CollectionMetadata, color: Option<&str>) {
        md.set_color(color);
    }

    pub fn setMtime(md: &mut CollectionMetadata, mtime: Option<i64>) {
        md.set_mtime(mtime);
    }
}

foreign_class!(class CollectionMetadata {
    self_type CollectionMetadata;
    constructor CollectionMetadata::new(type_: &str, name: &str) -> CollectionMetadata;
    fn CollectionMetadataFixes::setCollectionType(&mut self, type_: &str);
    fn CollectionMetadataFixes::setName(&mut self, name: &str);
    fn CollectionMetadataFixes::setDescription(&mut self, description: Option<&str>);
    fn CollectionMetadataFixes::setColor(&mut self, color: Option<&str>);
    fn CollectionMetadataFixes::setMtime(&mut self, mtime: Option<i64>);
    fn CollectionMetadata::collection_type(&self) -> &str; alias getCollectionType;
    fn CollectionMetadata::name(&self) -> &str; alias getName;
    fn CollectionMetadata::description(&self) -> Option<&str>; alias getDescription;
    fn CollectionMetadata::color(&self) -> Option<&str>; alias getColor;
    fn CollectionMetadata::mtime(&self) -> Option<i64>; alias getMtime;
});

mod ItemMetadataFixes {
    #![allow(non_snake_case)]
    use super::*;

    pub fn setItemType(md: &mut ItemMetadata, type_: Option<&str>) {
        md.set_item_type(type_);
    }

    pub fn setName(md: &mut ItemMetadata, name: Option<&str>) {
        md.set_name(name);
    }

    pub fn setMtime(md: &mut ItemMetadata, mtime: Option<i64>) {
        md.set_mtime(mtime);
    }
}

foreign_class!(class ItemMetadata {
    self_type ItemMetadata;
    constructor ItemMetadata::new() -> ItemMetadata;
    fn ItemMetadataFixes::setItemType(&mut self, type_: Option<&str>);
    fn ItemMetadataFixes::setName(&mut self, name: Option<&str>);
    fn ItemMetadataFixes::setMtime(&mut self, mtime: Option<i64>);
    fn ItemMetadata::item_type(&self) -> Option<&str>; alias getItemType;
    fn ItemMetadata::name(&self) -> Option<&str>; alias getName;
    fn ItemMetadata::mtime(&self) -> Option<i64>; alias getMtime;
});

pub fn col_fetch(mgr: &CollectionManager, col_uid: &str, fetch_options: Option<&FetchOptions>) -> Result<Collection> {
    let fetch_options = fetch_options.map(|x| x.to_fetch_options());
    mgr.fetch(col_uid, fetch_options.as_ref())
}

pub fn col_list(mgr: &CollectionManager, fetch_options: Option<&FetchOptions>) -> Result<CollectionListResponse> {
    let fetch_options = fetch_options.map(|x| x.to_fetch_options());
    mgr.list(fetch_options.as_ref())
}

pub fn col_upload(mgr: &CollectionManager, collection: &Collection, fetch_options: Option<&FetchOptions>) -> Result<()> {
    let fetch_options = fetch_options.map(|x| x.to_fetch_options());
    mgr.upload(collection, fetch_options.as_ref())
}

pub fn col_transaction(mgr: &CollectionManager, collection: &Collection, fetch_options: Option<&FetchOptions>) -> Result<()> {
    let fetch_options = fetch_options.map(|x| x.to_fetch_options());
    mgr.transaction(collection, fetch_options.as_ref())
}

foreign_class!(class CollectionManager {
    self_type CollectionManager;
    private constructor = empty;
    fn col_fetch(&self, col_uid: &str, fetch_options: Option<&FetchOptions>) -> Result<Collection>; alias fetch;
    fn CollectionManager::create(&self, meta: &CollectionMetadata, content: &[u8]) -> Result<Collection>; alias create;
    fn CollectionManager::item_manager(&self, col: &Collection) -> Result<ItemManager>; alias getItemManager;
    fn col_list(&self, fetch_options: Option<&FetchOptions>) -> Result<CollectionListResponse>; alias list;
    fn col_upload(&self, collection: &Collection, fetch_options: Option<&FetchOptions>) -> Result<()>; alias upload;
    fn col_transaction(&self, collection: &Collection, fetch_options: Option<&FetchOptions>) -> Result<()>; alias transaction;
});

pub fn item_fetch(mgr: &ItemManager, item_uid: &str, fetch_options: Option<&FetchOptions>) -> Result<Item> {
    let fetch_options = fetch_options.map(|x| x.to_fetch_options());
    mgr.fetch(item_uid, fetch_options.as_ref())
}

pub fn item_list(mgr: &ItemManager, fetch_options: Option<&FetchOptions>) -> Result<ItemListResponse> {
    let fetch_options = fetch_options.map(|x| x.to_fetch_options());
    mgr.list(fetch_options.as_ref())
}

pub fn item_fetch_updates(mgr: &ItemManager, items: Vec<&Item>, fetch_options: Option<&FetchOptions>) -> Result<ItemListResponse> {
    let fetch_options = fetch_options.map(|x| x.to_fetch_options());
    mgr.fetch_updates(items.into_iter(), fetch_options.as_ref())
}

// FIXME: make deps an option?
pub fn item_batch(mgr: &ItemManager, items: Vec<&Item>, deps: Vec<&Item>, fetch_options: Option<&FetchOptions>) -> Result<()> {
    let fetch_options = fetch_options.map(|x| x.to_fetch_options());
    mgr.batch_deps(items.into_iter(), deps.into_iter(), fetch_options.as_ref())
}

pub fn item_transaction(mgr: &ItemManager, items: Vec<&Item>, deps: Vec<&Item>, fetch_options: Option<&FetchOptions>) -> Result<()> {
    let fetch_options = fetch_options.map(|x| x.to_fetch_options());
    mgr.transaction_deps(items.into_iter(), deps.into_iter(), fetch_options.as_ref())
}

foreign_class!(class ItemManager {
    self_type ItemManager;
    private constructor = empty;
    fn item_fetch(&self, item_uid: &str, fetch_options: Option<&FetchOptions>) -> Result<Item>; alias fetch;
    fn ItemManager::create(&self, meta: &ItemMetadata, content: &[u8]) -> Result<Item>; alias create;
    fn item_list(&self, fetch_options: Option<&FetchOptions>) -> Result<ItemListResponse>; alias list;
    fn item_fetch_updates(&self, items: Vec<&Item>, fetch_options: Option<&FetchOptions>) -> Result<ItemListResponse>; alias fetchUpdates;
    fn item_batch(&self, items: Vec<&Item>, deps: Vec<&Item>, fetch_options: Option<&FetchOptions>) -> Result<()>; alias batch;
    fn item_transaction(&self, items: Vec<&Item>, deps: Vec<&Item>, fetch_options: Option<&FetchOptions>) -> Result<()>; alias transaction;
});

pub fn col_verify(col: &Collection) -> bool {
    col.verify().unwrap_or(false)
}

foreign_class!(class Collection {
    self_type Collection;
    private constructor = empty;
    fn col_verify(&self) -> bool; alias verify;

    fn Collection::set_meta(&mut self, meta: &CollectionMetadata) -> Result<()>; alias setMeta;
    fn Collection::decrypt_meta(&self) -> Result<CollectionMetadata>; alias getMeta;
    // FIXME Figure out how to support generic:
    // fn Collection::set_meta<T: MsgPackSerilization>(&mut self, meta: &T) -> Result<()>;
    // fn Collection::decrypt_meta_generic<T: MsgPackSerilization>(&self) -> Result<T::Output>;
    fn Collection::set_content(&mut self, content: &[u8]) -> Result<()>; alias setContent;
    fn Collection::decrypt_content(&self) -> Result<Vec<u8>>; alias getContent;
    fn Collection::delete(&mut self) -> Result<()>; alias markDeleted;
    fn Collection::is_deleted(&self) -> bool; alias isDeleted;
    fn Collection::uid(&self) -> &str; alias getUid;
    fn Collection::etag_owned(&self) -> Option<String>; alias getEtag;
    fn Collection::stoken(&self) -> Option<&str>; alias getStoken;
    fn Collection::item(&self) -> Result<Item>; alias asItem;
});

pub fn item_verify(item: &Item) -> bool {
    item.verify().unwrap_or(false)
}

foreign_class!(class Item {
    self_type Item;
    private constructor = empty;
    fn item_verify(&self) -> bool; alias verify;

    fn Item::set_meta(&mut self, meta: &ItemMetadata) -> Result<()>; alias setMeta;
    fn Item::decrypt_meta(&self) -> Result<ItemMetadata>; alias getMeta;
    // FIXME Figure out how to support generic:
    // FIXME fn Item::set_meta<T: MsgPackSerilization>(&mut self, meta: &T) -> Result<()>;
    // fn Item::decrypt_meta_generic<T: MsgPackSerilization>(&self) -> Result<T::Output>;
    fn Item::set_content(&mut self, content: &[u8]) -> Result<()>; alias setContent;
    fn Item::decrypt_content(&self) -> Result<Vec<u8>>; alias getContent;
    fn Item::delete(&mut self) -> Result<()>; alias markDeleted;
    fn Item::is_deleted(&self) -> bool; alias isDeleted;
    fn Item::uid(&self) -> &str; alias getUid;
    fn Item::etag_owned(&self) -> Option<String>; alias getEtag;
});

foreign_class!(class UserProfile {
    self_type UserProfile;
    private constructor = empty;
    fn UserProfile::pubkey(&self) -> &[u8]; alias getEmail;
});
