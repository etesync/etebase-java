use etebase::{
    User,
    Client,
    Account,

    Collection,
    CollectionMetadata,
    Item,
    ItemMetadata,

    CollectionAccessLevel,
    SignedInvitation,
    CollectionMember,
    RemovedCollection,

    UserProfile,

    utils::{
        from_base64,
        to_base64,
    },

    error::{
        Error,
        Result,
    },
    managers::{
        CollectionManager,
        ItemManager,
        CollectionInvitationManager,
        CollectionMemberManager,
    },
};

use crate::{
    Response,
    HttpClient,
    client_new_with_impl,

    FetchOptions,
};

#[cfg(feature = "java")]
use crate::jni_c_header::*;

#[cfg(feature = "android")]
use jni_sys::*;

fn response_reset_ok(resp: &mut Response, bytes: &[u8], status: u16) {
    resp.reset_ok(bytes.to_vec(), status);
}

foreign_class!(class Response {
    self_type Response;
    private constructor = empty;
    fn response_reset_ok(&mut self, bytes: &[u8], status: u16); alias reset_ok;
    fn Response::reset_err(&mut self, err: String);
});

type CallbackOption<T> = std::option::Option<T>;

foreign_callback!(callback HttpClient {
    self_type HttpClient;
    get = HttpClient::get(&self, url: &str, auth_token: CallbackOption<&str>, response: Response);
    post = HttpClient::post(&self, url: &str, auth_token: CallbackOption<&str>, body: Vec<u8>, response: Response);
    put = HttpClient::put(&self, url: &str, auth_token: CallbackOption<&str>, body: Vec<u8>, response: Response);
    patch = HttpClient::patch(&self, url: &str, auth_token: CallbackOption<&str>, body: Vec<u8>, response: Response);
    del = HttpClient::delete(&self, url: &str, auth_token: CallbackOption<&str>, response: Response);
});

foreign_class!(class Base64Url {
    fn from_base64(string: &str) -> Result<Vec<u8>>; alias fromBase64;
    fn to_base64(bytes: &[u8]) -> Result<String>; alias toBase64;
});

foreign_class!(class Client {
    self_type Client;
    private constructor = empty;
    fn client_new_with_impl(server_url: &str, imp: Box<HttpClient>) -> Result<Client>;
    fn Client::set_api_base(&mut self, server_url: &str) -> Result<()>; alias setApiBase;
    foreign_code r#"
    public static Client create(okhttp3.OkHttpClient client, String server_url) {
        return com.etebase.client.http_bridge.HttpClientBridge.create(client, server_url);
    }

    static {
        System.loadLibrary("etebase_android");
    }
"#;
});

foreign_class!(class User {
    self_type User;
    constructor User::new(username: &str, email: &str) -> User;
    fn setUsername(&mut self, username: &str) {
        this.set_username(username);
    }
    fn User::username(&self) -> &str; alias getUsername;
    fn setEmail(&mut self, email: &str) {
        this.set_email(email);
    }
    fn User::email(&self) -> &str; alias getEmail;
});

foreign_class!(class Account {
    self_type Account;
    private constructor = empty;
    fn login(client: &Client, username: &str, password: &str) -> Result<Account> {
        Account::login(client.clone(), username, password)
    }
    fn signup(client: &Client, user: &User, password: &str) -> Result<Account> {
        Account::signup(client.clone(), user, password)
    }
    fn Account::fetch_token(&mut self) -> Result<()>; alias fetchToken;
    fn Account::force_api_base(&mut self, api_base: &str) -> Result<()>; alias forceApiBase;
    fn Account::change_password(&mut self, password: &str) -> Result<()>; alias changePassword;
    fn Account::logout(&mut self) -> Result<()>;
    fn Account::collection_manager(&self) -> Result<CollectionManager>; alias getCollectionManager;
    fn Account::invitation_manager(&self) -> Result<CollectionInvitationManager>; alias getInvitationManager;

    fn Account::save(&self, encryption_key: Option<&[u8]>) -> Result<String>;
    fn restore(client: &Client, account_data_stored: &str, encryption_key: Option<&[u8]>) -> Result<Account> {
        Account::restore(client.clone(), account_data_stored, encryption_key)
    }
});

foreign_class!(class RemovedCollection {
    self_type RemovedCollection;
    private constructor = empty;
    fn RemovedCollection::uid(&self) -> &str;
});

type CollectionListResponse = etebase::CollectionListResponse<Collection>;

foreign_class!(class CollectionListResponse {
    self_type CollectionListResponse;
    private constructor = empty;
    fn CollectionListResponse::stoken(&self) -> Option<&str>; alias getStoken;
    fn CollectionListResponse::data(&self) -> &Vec<Collection>; alias getData;
    fn CollectionListResponse::done(&self) -> bool; alias getDone;
    fn getRemovedMemberships(&self) -> Vec<RemovedCollection> {
        match this.removed_memberships() {
            Some(removed) => removed.to_vec(),
            None => vec![],
        }
    }
});

type ItemListResponse = etebase::ItemListResponse<Item>;

foreign_class!(class ItemListResponse {
    self_type ItemListResponse;
    private constructor = empty;
    fn ItemListResponse::stoken(&self) -> Option<&str>; alias getStoken;
    fn ItemListResponse::data(&self) -> &Vec<Item>; alias getData;
    fn ItemListResponse::done(&self) -> bool; alias getDone;
});

foreign_class!(class FetchOptions {
    self_type FetchOptions;
    constructor FetchOptions::new() -> FetchOptions;
    fn FetchOptions::limit(&mut self, limit: usize);
    fn FetchOptions::prefetch(&mut self, prefetch: bool);
    fn FetchOptions::with_collection(&mut self, with_collection: bool);
    fn FetchOptions::iterator(&mut self, iterator: Option<&str>);
    fn FetchOptions::stoken(&mut self, stoken: Option<&str>);
});

mod CollectionMetadataFixes {
    #![allow(non_snake_case)]
    use super::*;

    pub fn setCollectionType(md: &mut CollectionMetadata, type_: &str) {
        md.set_collection_type(type_);
    }

    pub fn setName(md: &mut CollectionMetadata, name: &str) {
        md.set_name(name);
    }

    pub fn setDescription(md: &mut CollectionMetadata, description: Option<&str>) {
        md.set_description(description);
    }

    pub fn setColor(md: &mut CollectionMetadata, color: Option<&str>) {
        md.set_color(color);
    }

    pub fn setMtime(md: &mut CollectionMetadata, mtime: Option<i64>) {
        md.set_mtime(mtime);
    }
}

foreign_class!(class CollectionMetadata {
    self_type CollectionMetadata;
    constructor CollectionMetadata::new(type_: &str, name: &str) -> CollectionMetadata;
    fn CollectionMetadataFixes::setCollectionType(&mut self, type_: &str);
    fn CollectionMetadataFixes::setName(&mut self, name: &str);
    fn CollectionMetadataFixes::setDescription(&mut self, description: Option<&str>);
    fn CollectionMetadataFixes::setColor(&mut self, color: Option<&str>);
    fn CollectionMetadataFixes::setMtime(&mut self, mtime: Option<i64>);
    fn CollectionMetadata::collection_type(&self) -> &str; alias getCollectionType;
    fn CollectionMetadata::name(&self) -> &str; alias getName;
    fn CollectionMetadata::description(&self) -> Option<&str>; alias getDescription;
    fn CollectionMetadata::color(&self) -> Option<&str>; alias getColor;
    fn CollectionMetadata::mtime(&self) -> Option<i64>; alias getMtime;
});

mod ItemMetadataFixes {
    #![allow(non_snake_case)]
    use super::*;

    pub fn setItemType(md: &mut ItemMetadata, type_: Option<&str>) {
        md.set_item_type(type_);
    }

    pub fn setName(md: &mut ItemMetadata, name: Option<&str>) {
        md.set_name(name);
    }

    pub fn setMtime(md: &mut ItemMetadata, mtime: Option<i64>) {
        md.set_mtime(mtime);
    }
}

foreign_class!(class ItemMetadata {
    self_type ItemMetadata;
    constructor ItemMetadata::new() -> ItemMetadata;
    fn ItemMetadataFixes::setItemType(&mut self, type_: Option<&str>);
    fn ItemMetadataFixes::setName(&mut self, name: Option<&str>);
    fn ItemMetadataFixes::setMtime(&mut self, mtime: Option<i64>);
    fn ItemMetadata::item_type(&self) -> Option<&str>; alias getItemType;
    fn ItemMetadata::name(&self) -> Option<&str>; alias getName;
    fn ItemMetadata::mtime(&self) -> Option<i64>; alias getMtime;
});

pub fn col_fetch(mgr: &CollectionManager, col_uid: &str, fetch_options: Option<&FetchOptions>) -> Result<Collection> {
    let fetch_options = fetch_options.map(|x| x.to_fetch_options());
    mgr.fetch(col_uid, fetch_options.as_ref())
}

pub fn col_list(mgr: &CollectionManager, fetch_options: Option<&FetchOptions>) -> Result<CollectionListResponse> {
    let fetch_options = fetch_options.map(|x| x.to_fetch_options());
    mgr.list(fetch_options.as_ref())
}

pub fn col_upload(mgr: &CollectionManager, collection: &Collection, fetch_options: Option<&FetchOptions>) -> Result<()> {
    let fetch_options = fetch_options.map(|x| x.to_fetch_options());
    mgr.upload(collection, fetch_options.as_ref())
}

pub fn col_transaction(mgr: &CollectionManager, collection: &Collection, fetch_options: Option<&FetchOptions>) -> Result<()> {
    let fetch_options = fetch_options.map(|x| x.to_fetch_options());
    mgr.transaction(collection, fetch_options.as_ref())
}

foreign_class!(class CollectionManager {
    self_type CollectionManager;
    private constructor = empty;
    fn col_fetch(&self, col_uid: &str, fetch_options: Option<&FetchOptions>) -> Result<Collection>; alias fetch;
    fn CollectionManager::create(&self, meta: &CollectionMetadata, content: &[u8]) -> Result<Collection>; alias create;
    fn CollectionManager::item_manager(&self, col: &Collection) -> Result<ItemManager>; alias getItemManager;
    fn col_list(&self, fetch_options: Option<&FetchOptions>) -> Result<CollectionListResponse>; alias list;
    fn col_upload(&self, collection: &Collection, fetch_options: Option<&FetchOptions>) -> Result<()>; alias upload;
    fn col_transaction(&self, collection: &Collection, fetch_options: Option<&FetchOptions>) -> Result<()>; alias transaction;
    fn CollectionManager::cache_load(&self, cached: &[u8]) -> Result<Collection>; alias cacheLoad;
    fn CollectionManager::cache_save(&self, collection: &Collection) -> Result<Vec<u8>>; alias cacheSave;
    fn CollectionManager::cache_save_with_content(&self, collection: &Collection) -> Result<Vec<u8>>; alias cacheSaveWithContent;

    fn CollectionManager::member_manager(&self, col: &Collection) -> Result<CollectionMemberManager>; alias getMemberManager;
});

pub fn item_fetch(mgr: &ItemManager, item_uid: &str, fetch_options: Option<&FetchOptions>) -> Result<Item> {
    let fetch_options = fetch_options.map(|x| x.to_fetch_options());
    mgr.fetch(item_uid, fetch_options.as_ref())
}

pub fn item_list(mgr: &ItemManager, fetch_options: Option<&FetchOptions>) -> Result<ItemListResponse> {
    let fetch_options = fetch_options.map(|x| x.to_fetch_options());
    mgr.list(fetch_options.as_ref())
}

pub fn item_fetch_updates(mgr: &ItemManager, items: Vec<&Item>, fetch_options: Option<&FetchOptions>) -> Result<ItemListResponse> {
    let fetch_options = fetch_options.map(|x| x.to_fetch_options());
    mgr.fetch_updates(items.into_iter(), fetch_options.as_ref())
}

pub fn item_batch(mgr: &ItemManager, items: Vec<&Item>, deps: Option<Vec<&Item>>, fetch_options: Option<&FetchOptions>) -> Result<()> {
    let fetch_options = fetch_options.map(|x| x.to_fetch_options());
    match deps {
        Some(deps) => mgr.batch_deps(items.into_iter(), deps.into_iter(), fetch_options.as_ref()),
        None => mgr.batch(items.into_iter(), fetch_options.as_ref()),
    }
}

pub fn item_transaction(mgr: &ItemManager, items: Vec<&Item>, deps: Option<Vec<&Item>>, fetch_options: Option<&FetchOptions>) -> Result<()> {
    let fetch_options = fetch_options.map(|x| x.to_fetch_options());
    match deps {
        Some(deps) => mgr.transaction_deps(items.into_iter(), deps.into_iter(), fetch_options.as_ref()),
        None => mgr.transaction(items.into_iter(), fetch_options.as_ref()),
    }
}

foreign_class!(class ItemManager {
    self_type ItemManager;
    private constructor = empty;
    fn item_fetch(&self, item_uid: &str, fetch_options: Option<&FetchOptions>) -> Result<Item>; alias fetch;
    fn ItemManager::create(&self, meta: &ItemMetadata, content: &[u8]) -> Result<Item>; alias create;
    fn item_list(&self, fetch_options: Option<&FetchOptions>) -> Result<ItemListResponse>; alias list;
    fn item_fetch_updates(&self, items: Vec<&Item>, fetch_options: Option<&FetchOptions>) -> Result<ItemListResponse>; alias fetchUpdates;
    fn item_batch(&self, items: Vec<&Item>, deps: Option<Vec<&Item>>, fetch_options: Option<&FetchOptions>) -> Result<()>; alias batch;
    fn item_transaction(&self, items: Vec<&Item>, deps: Option<Vec<&Item>>, fetch_options: Option<&FetchOptions>) -> Result<()>; alias transaction;

    fn ItemManager::cache_load(&self, cached: &[u8]) -> Result<Item>; alias cacheLoad;
    fn ItemManager::cache_save(&self, item: &Item) -> Result<Vec<u8>>; alias cacheSave;
    fn ItemManager::cache_save_with_content(&self, item: &Item) -> Result<Vec<u8>>; alias cacheSaveWithContent;
});

pub fn col_verify(col: &Collection) -> bool {
    col.verify().unwrap_or(false)
}

foreign_class!(class Collection {
    self_type Collection;
    private constructor = empty;
    fn col_verify(&self) -> bool; alias verify;

    fn Collection::set_meta(&mut self, meta: &CollectionMetadata) -> Result<()>; alias setMeta;
    fn Collection::decrypt_meta(&self) -> Result<CollectionMetadata>; alias getMeta;
    fn Collection::set_meta_raw(&mut self, meta: &[u8]) -> Result<()>; alias setMetaRaw;
    fn Collection::decrypt_meta_raw(&self) -> Result<Vec<u8>>; alias getMetaRaw;
    fn Collection::set_content(&mut self, content: &[u8]) -> Result<()>; alias setContent;
    fn Collection::decrypt_content(&self) -> Result<Vec<u8>>; alias getContent;
    fn Collection::delete(&mut self) -> Result<()>; alias markDeleted;
    fn Collection::is_deleted(&self) -> bool; alias isDeleted;
    fn Collection::uid(&self) -> &str; alias getUid;
    fn Collection::etag_owned(&self) -> Option<String>; alias getEtag;
    fn Collection::stoken(&self) -> Option<&str>; alias getStoken;
    fn Collection::item(&self) -> Result<Item>; alias asItem;
});

pub fn item_verify(item: &Item) -> bool {
    item.verify().unwrap_or(false)
}

foreign_class!(class Item {
    self_type Item;
    private constructor = empty;
    fn item_verify(&self) -> bool; alias verify;

    fn Item::set_meta(&mut self, meta: &ItemMetadata) -> Result<()>; alias setMeta;
    fn Item::decrypt_meta(&self) -> Result<ItemMetadata>; alias getMeta;
    fn Item::set_meta_raw(&mut self, meta: &[u8]) -> Result<()>; alias setMetaRaw;
    fn Item::decrypt_meta_raw(&self) -> Result<Vec<u8>>; alias getMetaRaw;
    fn Item::set_content(&mut self, content: &[u8]) -> Result<()>; alias setContent;
    fn Item::decrypt_content(&self) -> Result<Vec<u8>>; alias getContent;
    fn Item::delete(&mut self) -> Result<()>; alias markDeleted;
    fn Item::is_deleted(&self) -> bool; alias isDeleted;
    fn Item::uid(&self) -> &str; alias getUid;
    fn Item::etag_owned(&self) -> Option<String>; alias getEtag;
});

foreign_class!(class UserProfile {
    self_type UserProfile;
    private constructor = empty;
    fn UserProfile::pubkey(&self) -> &[u8]; alias getEmail;
});

type InvitationListResponse = etebase::IteratorListResponse<SignedInvitation>;

foreign_class!(class InvitationListResponse {
    self_type InvitationListResponse;
    private constructor = empty;
    fn InvitationListResponse::iterator(&self) -> Option<&str>; alias getStoken;
    fn InvitationListResponse::data(&self) -> &Vec<SignedInvitation>; alias getData;
    fn InvitationListResponse::done(&self) -> bool; alias getDone;
});

mod CollectionInvitationManagerFixes {
    #![allow(non_snake_case)]
    use super::*;

    pub fn list_incoming(mgr: &CollectionInvitationManager, fetch_options: Option<&FetchOptions>) -> Result<InvitationListResponse> {
        let fetch_options = fetch_options.map(|x| x.to_fetch_options());
        mgr.list_incoming(fetch_options.as_ref())
    }

    pub fn list_outgoing(mgr: &CollectionInvitationManager, fetch_options: Option<&FetchOptions>) -> Result<InvitationListResponse> {
        let fetch_options = fetch_options.map(|x| x.to_fetch_options());
        mgr.list_outgoing(fetch_options.as_ref())
    }
}

foreign_class!(class CollectionInvitationManager {
    self_type CollectionInvitationManager;
    private constructor = empty;

    fn CollectionInvitationManagerFixes::list_incoming(&self, options: Option<&FetchOptions>) -> Result<InvitationListResponse>; alias listIncoming;
    fn CollectionInvitationManagerFixes::list_outgoing(&self, options: Option<&FetchOptions>) -> Result<InvitationListResponse>; alias listOutgoing;
    fn CollectionInvitationManager::accept(&self, invitation: &SignedInvitation) -> Result<()>;
    fn CollectionInvitationManager::reject(&self, invitation: &SignedInvitation) -> Result<()>;
    fn CollectionInvitationManager::fetch_user_profile(&self, username: &str) -> Result<UserProfile>; alias fetchUserProfile;
    fn invite(&self, collection: &Collection, username: &str, pubkey: &[u8], access_level: &str) -> Result<()> {
        this.invite(collection, username, pubkey, &CollectionAccessLevel::from(access_level))
    }
    fn CollectionInvitationManager::disinvite(&self, invitation: &SignedInvitation) -> Result<()>;
    fn CollectionInvitationManager::pubkey(&self) -> &[u8];
});

foreign_class!(class SignedInvitation {
    self_type SignedInvitation;
    private constructor = empty;

    fn SignedInvitation::uid(&self) -> &str; alias getUid;
    fn SignedInvitation::username(&self) -> &str; alias getUsername;
    fn SignedInvitation::collection(&self) -> &str; alias getCollection;
    fn getAccessLevel(&self) -> String {
        String::from(this.access_level())
    }
    fn SignedInvitation::from_pubkey(&self) -> &[u8]; alias getFromPubkey;
});

foreign_class!(class CollectionMember {
    self_type CollectionMember;
    private constructor = empty;

    fn CollectionMember::username(&self) -> &str; alias getUsername;
    fn getAccessLevel(&self) -> String {
        String::from(this.access_level())
    }
});

type MemberListResponse = etebase::IteratorListResponse<CollectionMember>;

foreign_class!(class MemberListResponse {
    self_type MemberListResponse;
    private constructor = empty;
    fn MemberListResponse::iterator(&self) -> Option<&str>; alias getStoken;
    fn MemberListResponse::data(&self) -> &Vec<CollectionMember>; alias getData;
    fn MemberListResponse::done(&self) -> bool; alias getDone;
});

foreign_class!(class CollectionMemberManager {
    self_type CollectionMemberManager;
    private constructor = empty;

    fn list(&self, fetch_options: Option<&FetchOptions>) -> Result<MemberListResponse> {
        let fetch_options = fetch_options.map(|x| x.to_fetch_options());
        this.list(fetch_options.as_ref())
    }
    fn CollectionMemberManager::remove(&self, username: &str) -> Result<()>;
    fn CollectionMemberManager::leave(&self) -> Result<()>;
    fn modifyAccessLevel(&self, username: &str, access_level: &str) -> Result<()> {
        this.modify_access_level(username, &CollectionAccessLevel::from(access_level))
    }
});
